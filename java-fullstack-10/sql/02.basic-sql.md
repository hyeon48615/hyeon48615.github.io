# CRUD 란?
대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말 <span style="font-size: small;"><a href="https://ko.wikipedia.org/wiki/CRUD">_위키백과</a></span>

### 예시
```sql
INSERT INTO 테이블명 (컬럼, ...) VALUES (값, ...);          -- 데이터 생성(CREATE)
SELECT * FROM 테이블명;                                     -- 데이터 조회(READ)
UPDATE 테이블명 SET 컬럼1 = 값1, 컬럼2 = 값2 WHERE 조건;     -- 데이터 수정(UPDATE)
DELETE FROM 테이블명 WHERE 조건;                            -- 데이터 삭제(DELETE)
```

# 데이터베이스 관리
- `SHOW DATABASES`: 현재 서버에 설치되어 있는 DB 목록 출력
- `USE 데이터베이스이름`: 사용할 데이터베이스 선택
- `CREATE DATABASE 데이터베이스이름`: 새로 데이터베이스를 생성
- `DROP DATABASE 데이터베이스이름`: 기존에 있는 데이터베이스를 삭제

# 테이블 관리
## 테이블 조회
- `SHOW TABLES`: 현재 접속한 데이터베이스에 등록되어 있는 테이블 목록 출력
- `DESC 테이블명`: 해당 테이블의 스키마 정보 조회

## 테이블 생성
> ``` sql
> CREATE TABLE [IF NOT EXISTS] 테이블명 (
>   칼럼정의,
>   제약정의
> )
> COMMENT 설명
> COLLATE 문자셋 지정
> ENGINE = INNODB
> ;
> ```

#### 테이블 생성
`CREATE TABLE 테이블명;` 로 테이블을 생성하고, `IF NOT EXISTS` 을 주어 해당 테이블명을 가진 테이블이 없을 때, 테이블을 생성하도록 할 수 있습니다.

#### 칼럼정의
기본적으로 `칼럼명 자료형`으로 테이블의 열을 정의하며, `NULL 허용여부, DEFAULT 기본값, COMMENT 설명, COLLATE 지정, UNIQUE | PRIMARY KEY, AUTO_INCREMENT` 등의 추가 정의를 할 수 있습니다.

#### COLLATE 와 ENGINE 지정
따로 명시하지 않을 경우, 시스템이 정한 기본값으로 자동 지정됩니다.

### 테이블 생성 예시
다음은 회원 정보를 담는 tbl_member 테이블 생성 쿼리 구문입니다.

```sql
CREATE TABLE `tbl_member` (
    `idx` INT(11) NOT NULL AUTO_INCREMENT COMMENT '인덱스',
    `memberId` VARCHAR(20) NOT NULL COMMENT '회원ID' COLLATE 'utf8mb4_unicode_ci',
    PRIMARY KEY (`memberId`) USING BTREE,
    UNIQUE INDEX `idx` (`idx`) USING BTREE
)
COMMENT='회원테이블'
COLLATE='utf8mb4_unicode_ci'
ENGINE=InnoDB
;
```

## 테이블 수정
- `ALTER TABLE`로 기존 테이블의 구조를 변경합니다. 
  - 열을 추가하거나 삭제하고, 제약사항을 추가할 수 있습니다. 
  - 열의 유형을 변경하거나 열 또는 테이블 이름을 수정할 수 있습니다. 
  - 테이블의 주석(`COMMENT`)과 엔진(`ENGINE`)을 변경할 수 있습니다.
- 어떤 열(또는 열 조합)에 UNIQUE 인덱스를 추가하면, 중복된 값이 있으면 오류가 나고 실행이 멈춥니다. 이 때, `IGNORE` 옵션을 사용하면, 중복된 값을 자동으로 삭제한 후 인덱스를 만듭니다. 그러나, 어떤 행이 남고 어떤 행이 삭제될 지 직접 지정할 수 없습니다.

### 열 추가
#### 기본형
> ``` sql
> ALTER TABLE 테이블명 ADD COLUMN [IF NOT EXISTS] (칼럼정의);
> ```

#### NULL 허용여부 설정
MariaDB는 기본값이 없을 경우, 기존 행에 대해 `NULL` 값을 자동으로 넣습니다. 따라서, `NOT NULL`을 지정하여 새로운 열을 추가하면 오류가 발생합니다.

따라서, NOT NULL을 설정할 때는 기본값(`DEFAULT`)을 함께 지정해야합니다.
``` sql
ALTER TABLE users
ADD COLUMN age INT NOT NULL DEFAULT 0;
```
또는, 우선 `NULL`을 허용한 후, 기본값을 설정하여 `NOT NULL` 제약 조건을 적용할 수 있습니다.
``` sql
ALTER TABLE users
ADD COLUMN age INT NULL;

UPDATE users SET age = 0 WHERE age IS NULL; -- 기본값 설정

ALTER TABLE users
MODIFIY COLUMN age INT NOT NULL;            -- NOT NULL 제약사항 추가
```

#### 예시
``` sql
ALTER TABLE tbl_member ADD COLUMN 
(`arr1` VARCHAR(100) NULL COMMENT '주소1',
 `arr2` VARCHAR(100) NULL COMMNET '상세주소');
```

### 열 삭제
#### 기본형
> ``` sql
> ALTER TABLE 테이블명 DROP COLUMN [IF EXISTS] 칼럼명 [CASCADE | RESTRICT]
> ```

#### 다중 열 UNIQUE 제약 조건
여러 개의 열(칼럼)로 이루어진 다중 열 UNIQUE 제약 조건이 있을 때, 그 중 하나의 열을 바로 삭제할 수 없습니다.

예를 들어, `(col1, col2)` 두 개의 열이 같이 UNIQUE 하도록 설정되어 있다고 가정합시다. 여기서 `col1`을 삭제하면, `(col1, col2)`라는 규칙이 깨지고, `col2`만 UNIQUE한 것 처럼 보일 수 있습니다. 하지만, 원래 `col2`는 단독으로 UNIQUE 하다는 보장이 없기 때문에, 데이터 무결성이 깨질 가능성이 있으므로 삭제가 막혀있습니다.

다중 열 UNIQUE 제약 조건이 걸린 열을 삭제하기 위해서는 다음과 같은 방법을 사용합니다.
1. 먼저 UNIQUE 제약 조건을 삭제합니다.
``` sql
ALTER TABLE my_table DROP CONSTRAINT unique_col;
```

2. 그 다음 원하는 열을 삭제합니다.
``` sql
ALTER TABLE my_table DROP COLUMN col1;
```

3. 필요하면 새로운 UNIQUE 제약 조건을 다시 추가합니다.
``` sql
ALTER TABLE my_table ADD CONSTRAINT new_unique_col UNIQUE (col2);
```

### 열 수정
#### 열 유형 수정
> ``` sql
> ALTER TABLE 테이블명 MODIFY 열이름 칼럼정의;
> ```

#### 열의 이름과 유형 수정
> ``` sql
> ALTER TABLE 테이블명 CHANGE 기존열이름 바꿀열이름 칼럼정의;
> ```

#### 제약 조건 추가
> ``` sql
> ALTER TABLE 테이블명
> ADD CONSTRAINT [제약조건명] 제약조건(표현식);
> ```

#### 제약 조건 삭제
> ``` sql
> ALTER TABLE 테이블명
> DROP CONSTRAINT 제약조건명;
> ```

#### 예시
``` sql
-- 열 유형 수정 
ALTER TABLE my_table MODIFY col1 BIGINT UNSIGNED;

-- 열 이름과 유형 수정
ALTER TABLE my_table CHANGE col1 new_col1 BIGINT UNSIGNED;

-- 열 삭제, 추가, 수정 한 번에 처리
ALTER TABLE my_table DROP col1, ADD col2 INT, CHANGE col3 new_col3 INT;

-- col1 칼럼에 기본키 추가
ALTER TABLE my_table ADD CONSTRAINT PRIMARY KEY(col1);

-- 기본키 삭제
ALTER TABLE my_table DROP CONSTRAINT PRIMARY KEY;
```

### 스토리지 엔진 / 주석 변경
> ``` sql
> ALTER TABLE 테이블명 ENGINE = 엔진;
> ALTER TABLE 테이블명 COMMENT = 코멘트;
> ```

### 테이블 재생성
> ``` sql
> ALTER TABLE 테이블명 FORCE;
> ```

테이블을 강제로 작동시키는 옵션입니다. 테이블을 재정렬하고 최적화하여 프래그먼테이션(조각화) 현상을 해결하고, 변경 사항을 강제로 적용할 때 사용합니다.

## 테이블 삭제
테이블 삭제는 롤백이 불가능하므로, 백업을 해두는 것이 좋습니다.

### DROP
> ``` sql
> DROP TABLE 테이블명;
> ```

테이블 자체를 삭제합니다.

### TRUNCATE
> ``` sql
> TRUNCATE TABLE 테이블명;
> ```

테이블의 모든 데이터가 삭제되며, 인덱스도 함께 지워집니다. 
- 스키마가 초기화되는 효과 
- 테이블의 구조(칼럼, 데이터 타입 등)는 유지되지만, 저장된 데이터와 관련된 모든 정보(데이터, 인덱스, 자동 증가 값 등)가 초기 상태로 돌아감
- 새 테이블을 만든 것 처럼 초기 상태로 돌아감

### 💡 DROP VS TRUNCATE VS DELETE
<style>
  tr {
  	text-align: center;
  }
</style>
<table style="width: 100%">
    <thead>
        <tr>
            <th>DROP</th>
            <th>TRUNCATE</th>
            <th>DELETE</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2">DDL</td>
            <td>DML</td>
        </tr>
        <tr>
            <td colspan="2">Auto Commit</td>
            <td>사용자 Commit</td>
        </tr>
        <tr>
            <td colspan="2">Rollback 불가능</td>
            <td>Rollback 가능</td>
        </tr>
        <tr>
            <td>테이블이 사용했던 Storage를 모두 Release</td>
            <td>테이블이 사용했던 Storage 중 최초 테이블 생성시 할당된 Storage만 남기고 Release</td>
            <td>데이터를 모두 Delete해도 사용했던 Storage는 Release되지 않음</td>
        </tr>
        <tr>
            <td>테이블 정의 자체를 삭제</td>
            <td>테이블을 최초 생성된 초기상태로 만듦</td>
            <td>데이터만 삭제</td>
        </tr>
    </tobdy>
</table>

# 데이터 관리
#### my_table 생성하기
자동으로 증가하는 인덱스, 이름, 직업, 생성일을 갖는 테이블을 생성하겠습니다.
``` sql
CREATE TABLE `my_table` (
	`idx` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(20) NOT NULL,
	`job` VARCHAR(20) NULL DEFAULT NULL,
	`createdAt` DATETIME NULL DEFAULT current_timestamp(),
	PRIMARY KEY (`name`) USING BTREE,
	UNIQUE INDEX `idx` (`idx`) USING BTREE
);
```

## 데이터 등록
> ``` sql
> INSERT INTO 테이블명 (컬럼1, 컬럼2, ...)
> VALUES (값1, 값2, ...);
> ```

#### 경우 1. 모든 칼럼에 값 넣기
``` sql
INSERT INTO my_table VALUES (NULL, 'LEE', NULL, DEFAULT);
```

테이블에 존재하는 **모든 칼럼**에 **순서대로** 값을 넣어야 합니다. NULL 값 허용인 칼럼도 포함됩니다.
- idx: `AUTO_INCREMENT`이므로 `NULL`을 넣을 경우 자동 증가
- createdAt: 기본값(`current_timestamp()`)을 사용

#### 경우 2. 특정 칼럼 지정하여 값 넣기
``` sql
INSERT INTO my_table (`name`) VALUES ('PARK');
```

**원하는 칼럼을 지정**하여 값을 넣을 수 있습니다. 테이블 정의 시의 칼럼 순서를 지키지 않고, **직접 작성한 칼럼 순서대로** 값을 작성합니다. **NOT NULL로 설정된 값**의 경우, DEFAULT가 없을 시에는 **반드시 칼럼을 지정**하여 값을 넣어줘야 합니다.

#### 경우 3. 여러 개의 데이터 한번에 넣기
``` sql
INSERT INTO my_table (`name`, `job`) VALUES ('CHOI', 'STUDENT'), ('KIM', NULL);
```

괄호와, 쉼표로 구분하여 여러 개의 데이터를 한 번에 추가할 수 있습니다.

## 데이터 조회
> ``` sql
> SELECT 칼럼명, ...
> FROM 테이블명
> [
> WHERE 조건
> GROUP BY 집계함수에서 사용할 기준 컬럼
> HAVING 집계함수 (GROUP BY)에서 사용할 조건절
> ORDER BY 정렬조건 [ASC(default) | DESC]
> LIMIT 시작인덱스, 개수
> ]
> ```

### 기본 문법
#### * (asterisk, 애스터리스크)
``` sql
SELECT * FROM my_table;
```

\* (asterisk, 애스터리스크)를 사용하여 선택한 테이블의 모든 값을 가져옵니다. 이러한 방법은 쿼리 성능 저하를 가져오므로 사용하지 않는 것이 좋습니다.

#### 칼럼 조회
``` sql
SELECT `name`, `job` FROM my_table;
```

칼럼을 선택하여, 해당 칼럼 혹은 여러 개의 칼럼 값을 가져옵니다.

#### AS(alias) 별칭
``` sql
SELECT t.`name` AS my_name
     , t.job AS my_job
FROM my_table AS t;
```
테이블이나 칼럼에 별칭을 붙여 사용할 수 있습니다.

#### DISTINCT 중복 제거
```sql
-- (1)
SELECT job FROM my_table;

# | job
1 | STUDENT
2 | TEACHER
3 | (NULL)
4 | (NULL)
5 | STUDENT

-- (2) 
SELECT DISTINCT job FROM my_table;

# | job
1 | STUDENT
2 | TEACHER
3 | (NULL)

```

검색 결과에 대해 중복이 있을 경우, 제거해 줍니다.

#### LIKE 정규표현식
``` sql
SELECT `name`
FROM my_table
WHERE `name` LIKE 'L%';
```

LIKE는 정규표현식을 만족하는 데이터를 조회합니다. 예제는 name 칼럼이 'L'로 시작하는 데이터를 찾습니다.

## 데이터 수정
> ``` sql
> UPDATE 테이블명
> SET 칼럼1 = 값1, 칼럼2 = 값2, ...
> WHERE 조건;
> ```

지정한 칼럼의 값을 수정합니다. WHERE 조건절로 수정하고자 하는 행을 선택할 수 있습니다.

# 데이터 복구
``` sql
START TRANSACTION;

UPDATE my_table
SET `job` = 'OFFICER'
WHERE `name` = 'KIM';

ROLLBACK;
COMMIT;
```
`START TRANSACTION`을 통해 안전하게 데이터를 수정할 수 있습니다. `ROLLBACK`을 하면 트랜잭션을 시작한 곳으로 되돌아 갑니다. 이후 `COMMIT`을 통해 변경한 데이터를 저장할 수 있고, `COMMIT`이 된 이후로는 다시 이전으로 되돌아 갈 수 없습니다.

## 데이터 삭제
> ``` sql
> DELETE FROM 테이블명 [WHERE 조건];
> ```

한 행씩 순회하며 삭제되며, 데이터만 삭제되고 디스크 상의 공간은 유지 됩니다.
WHERE 조건절을 두어 조건에 맞는 행을 삭제할 수 있습니다.

#### 데이터 복구
``` sql
START TRANSACTION;

DELETE FROM my_table
WHERE `name` = 'KIM';

ROLLBACK;
COMMIT;
```
`UPDATE`와 마찬가지로 `START TRANSACTION ~ ROLLBACK`을 통해 안전하게 데이터를 삭제하고 복구할 수 있습니다.

참고 
- SQL 전문가 가이드 (한국데이터산업진흥원, 2021)
- https://shlee1990.tistory.com/738
- https://innovation123.tistory.com/44#INSERT%20INTO%20%3A%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B6%94%EA%B0%80-1